application {
    config {
        applicationType monolith,
        baseName autocut,
        packageName de.farue.autocut,
        authenticationType jwt,
        cacheProvider ehcache,
        buildTool gradle,
        databaseType sql,
        devDatabaseType mysql,
        prodDatabaseType mysql,
        enableTranslation true,
        nativeLanguage de,
        languages [de, en],
        clientTheme materia,
        clientThemeVariant light
    }
    entities *
    paginate InternalTransaction with pagination
}

// ****************************************************
// * Tenant Manaagement
// ****************************************************

@service(serviceClass)
entity Tenant {
    firstName String required
    lastName String required
	pictureId ImageBlob
	verified Boolean
}

@service(serviceClass)
entity Lease {
	nr String required // number given by StW, e.g. 30-41
	start LocalDate required
    end LocalDate required
    blocked Boolean
    pictureContract ImageBlob
}

entity SecurityPolicy {
	protectionUnit ProtectionUnits required
    access Access required
}

enum Access {
	READ_ALLOW,
    READ_WRITE_ALLOW,
    WRITE_DENY,
    READ_WRITE_DENY
}

enum ProtectionUnits {
	BANK_TRANSACTIONS,
    TENANT_MANAGEMENT,
    INTERNET_ACCESS_MANAGEMENT,
    TOOLS_MANAGEMENT,
    WASHING_SYSTEM_MANAGEMENT
}

relationship OneToOne {
	// Each tenant should have a user profile
    // Not every user belongs to a tenant, e.g. admin user
	Tenant{user} to User
}

relationship OneToMany {
    Lease{tenants} to Tenant{lease}
    Apartment{leases} to Lease{apartment}
}

relationship ManyToMany {
    Lease to TransactionBook
}


// ****************************************************
// * Apartment & Address
// ****************************************************

@service(serviceClass)
entity Apartment {
    // simple apartment nr, cannot be stw number because there are two different ones for shared apartments
	nr String required
    type ApartmentTypes required
    maxNumberOfLeases Integer required min(0)
}

// We can get this from maxNumberOfLeases
// -> does not need to be persisted
enum ApartmentTypes {
    SHARED,
    SINGLE,
    SHORT_TERM,
    BACKUP
}

@service(serviceClass)
entity Address {
	street String required
	streetNumber String required
    zip String required pattern(/^\d{5}$/)
    city String required
    country String required
}

relationship ManyToOne {
	Apartment{address} to Address
}

// Internet Access

@service(serviceClass)
entity InternetAccess {
    ip1 String required
    ip2 String required
    switchInterface String required
    port Integer required min(1)
}

// only holds the most recent status (cache for current switch status)
@service(serviceClass)
entity NetworkSwitchStatus {
    port String
    name String
    status String
    vlan String
    speed String
    type String
    timestamp Instant
}

@service(serviceClass)
entity NetworkSwitch {
    interfaceName String required
    sshHost String required
}

relationship OneToOne {
	Apartment{internetAccess} to InternetAccess{apartment}
}

relationship ManyToOne {
	InternetAccess{networkSwitch} to NetworkSwitch
	NetworkSwitchStatus{networkSwitch} to NetworkSwitch
}


// ****************************************************
// * Teams
// ****************************************************

entity Team {
	name String required
	email String
}

entity TeamMembership {
	role TeamRole
	start LocalDate
	end LocalDate
}

enum TeamRole {
	SPOKESPERSON,
    DEPUTY,
    MEMBER
}

/**
  * Activity always describes an entire semester since its main purpose is to capture who is
  * eligible for a discount, and its secondary purpose is to store activity counted at StW.
  * Both these things are in terms of full semesters.
  */
@service(serviceClass)
entity Activity {
	year Integer required
    term SemesterTerms required
    // only use start and end date for short activities that do not last an entire semester
    start LocalDate
    end LocalDate
    description String
    // whether or not the tenant should get a discount next semester
    discount Boolean
    // whether or not this activity is sent to StW
    stwActivity Boolean
}

enum SemesterTerms {
	SUMMER_TERM,
    WINTER_TERM
}

relationship ManyToOne {
    TeamMembership{tenant} to Tenant
    Activity{tenant} to Tenant
    Activity{teamMembership} to TeamMembership
}

relationship OneToMany {
    Team{teamMembership} to TeamMembership{team required}
	TeamMembership{securityPolicies} to SecurityPolicy{teamMember}
    Tenant{securityPolicies} to SecurityPolicy{tenant}
}


// ****************************************************
// * Accounting
// ****************************************************

@service(serviceClass)
entity TransactionBook {
    name String,
    type TransactionBookType required
}

@service(serviceClass)
entity InternalTransaction {
	type String required
	bookingDate Instant required
    valueDate Instant required
    value BigDecimal required
    balanceAfter BigDecimal required
    description String
    serviceQulifier String
    issuer String required
    recipient String
}

/**
 * FEE: A transaction with negative amount. The difference between a fee and a purchase is that a
 * fee is not paid in exchange for an immediate good.
 * CREDIT: A transaction with a positive amount. The amount is credited to the account.
 * DEBIT: A transaction with a negative amount. The amount is withdrawn from the account.
 * TRANSFER: A transfer to a different account.
 * CORRECTION: A corrective booking due to cancellation or system malfunctions.
 * PURCHASE: A transaction with a negative amount. In exchange the payer receives a different good.
 */
enum TransactionType {
	FEE,
    CREDIT,
    DEBIT,
    TRANSFER,
    CORRECTION,
    PURCHASE
}

enum TransactionBookType {
    CASH,
    REVENUE,
    DEPOSIT
}

relationship OneToMany {
    // A transaction book can only ever have one type of transactions
	TransactionBook{iTransaction} to InternalTransaction{transactionBook required}
	TransactionBook{bTransaction} to BankTransaction{transactionBook required}
}

relationship ManyToMany {
    InternalTransaction{left} to InternalTransaction{right}
    BankTransaction{left} to BankTransaction{right}
}

@service(serviceClass)
entity BankAccount {
    name String required
    bic String maxlength(11) required
    iban String maxlength(34) required unique
}

@service(serviceClass)
entity BankTransaction {
    bookingDate Instant required
    valueDate Instant required
    value BigDecimal required
    balanceAfter BigDecimal required
    type String
    description String
    customerRef String
    gvCode String
    endToEnd String
    primanota String
    creditor String
    mandate String
}

relationship ManyToOne {
    BankTransaction{bankAccount required} to BankAccount
    BankTransaction{contraBankAccount} to BankAccount
}

// ****************************************************
// * Communication
// ****************************************************

entity Communication {
    subject String required maxlength(80)
	text TextBlob required
	note TextBlob
    date Instant required
}

relationship ManyToOne {
	Communication{tenant} to User
}

// ****************************************************
// * Wash System
// ****************************************************

@service(serviceClass)
entity LaundryMachine (wash_machine) {
    identifier String required
	name String required
    type LaundryMachineType required
    enabled Boolean required
    positionX Integer required
    positionY Integer required
}

entity LaundryProgram (wash_program) {
	name String required
    subprogram String
    // washing machine
    spin Integer
    preWash Boolean
    // dryer
    protect Boolean
}

entity LaundryMachineProgram (wash_machine_program) {
    time Integer required
}

entity WashHistory (wash_history) {
	usingDate Instant
    reservationDate Instant
    lastModifiedDate Instant
    status WashHistoryStatus
}

enum WashHistoryStatus {
	OPEN,
    EXPIRED,
    COMPLETED,
	CANCELLED_BY_USER,
    CANCELLED_BY_SYSTEM
}

enum LaundryMachineType {
	WASHING_MACHINE,
    DRYER
}

relationship OneToMany {
	LaundryMachine{programs} to LaundryMachineProgram{machine required}
}

relationship ManyToOne {
    LaundryMachineProgram{program required} to LaundryProgram
	WashHistory{reservationTenant} to Tenant
    WashHistory{usingTenant} to Tenant
	WashHistory{machine} to LaundryMachine
	WashHistory{program} to LaundryMachineProgram
}

// ****************************************************
// * Timesheet
// ****************************************************

@service(serviceClass)
entity Timesheet {
    enabled Boolean required
}

@service(serviceClass)
entity TimesheetTime {
    start Instant
    end Instant
    effectiveTime Integer required
    pause Integer required
    description String required maxlength(1000)
    editedFactor BigDecimal
    editedConstant Integer
}

@service(serviceClass)
entity TimesheetTimer {
    start Instant required
    pauseStart Instant
    pause Integer
}

@service(serviceClass)
entity TimesheetTask {
    name String required
    enabled Boolean required
    constant Integer required
    constantEditable Boolean required
    factor BigDecimal required
    factorEditable Boolean required
    defaultTimespan Integer
}

@service(serviceClass)
entity TimesheetProject {
    name String required
    start Instant
    end Instant
}

@service(serviceClass)
entity TimesheetProjectMember {
    start Instant
    end Instant
}

relationship OneToOne {
    Timesheet{member required} to Tenant
    TimesheetTimer{timesheet required} to Timesheet
}

relationship ManyToOne {
    TimesheetTime{timesheet required} to Timesheet
    TimesheetTime{project required} to TimesheetProject
    TimesheetTime{task required} to TimesheetTask
    TimesheetProject{owner required} to Tenant
    TimesheetProjectMember{project required} to TimesheetProject
    TimesheetProjectMember{timesheet required} to Timesheet
}

relationship ManyToMany {
    TimesheetProject{tasks} to TimesheetTask{projects}
}

// ****************************************************
// * Reward
// ****************************************************

@service(serviceClass)
entity RewardTimeReview {
    status RewardTimeReviewStatus
    comment String maxlength(4000)
}

@service(serviceClass)
entity RewardPayout {
    timestamp Instant
    amount BigDecimal
    time Integer
}

enum RewardTimeReviewStatus {
    OK,
    NOK,
    PENDING
}

relationship OneToOne {
    RewardTimeReview{timesheetTime required} to TimesheetTime
}

relationship ManyToOne {
    RewardPayout{timesheet required} to Timesheet
}

// ****************************************************
// * Global
// ****************************************************

entity GlobalSetting {
	key String,
    value String,
    valueType String
}

entity BroadcastMessage {
    type BroadcastMessageType required
    start Instant
    end Instant
    usersOnly Boolean
    dismissible Boolean
}

entity BroadcastMessageText {
    langKey String required maxlength(2)
    text String required maxlength(4000)
}

enum BroadcastMessageType {
    PRIMARY
    SECONDARY
    SUCCESS
    DANGER
    WARNING
    INFO
    LIGHT
    DARK
}

relationship OneToMany {
    BroadcastMessage{messageText} to BroadcastMessageText{message required}
}
